// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'image_cropper_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$ImageCropperStateTearOff {
  const _$ImageCropperStateTearOff();

  _Initial initial() {
    return const _Initial();
  }

  _NewImageLoaded newImageLoaded(Uint8List imageData) {
    return _NewImageLoaded(
      imageData,
    );
  }

  _CropperOpened cropperOpened() {
    return const _CropperOpened();
  }

  _NewImageCropped newImageCropped(Uint8List imageData) {
    return _NewImageCropped(
      imageData,
    );
  }
}

/// @nodoc
const $ImageCropperState = _$ImageCropperStateTearOff();

/// @nodoc
mixin _$ImageCropperState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(Uint8List imageData) newImageLoaded,
    required TResult Function() cropperOpened,
    required TResult Function(Uint8List imageData) newImageCropped,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(Uint8List imageData)? newImageLoaded,
    TResult Function()? cropperOpened,
    TResult Function(Uint8List imageData)? newImageCropped,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(Uint8List imageData)? newImageLoaded,
    TResult Function()? cropperOpened,
    TResult Function(Uint8List imageData)? newImageCropped,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_NewImageLoaded value) newImageLoaded,
    required TResult Function(_CropperOpened value) cropperOpened,
    required TResult Function(_NewImageCropped value) newImageCropped,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_NewImageLoaded value)? newImageLoaded,
    TResult Function(_CropperOpened value)? cropperOpened,
    TResult Function(_NewImageCropped value)? newImageCropped,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_NewImageLoaded value)? newImageLoaded,
    TResult Function(_CropperOpened value)? cropperOpened,
    TResult Function(_NewImageCropped value)? newImageCropped,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ImageCropperStateCopyWith<$Res> {
  factory $ImageCropperStateCopyWith(
          ImageCropperState value, $Res Function(ImageCropperState) then) =
      _$ImageCropperStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$ImageCropperStateCopyWithImpl<$Res>
    implements $ImageCropperStateCopyWith<$Res> {
  _$ImageCropperStateCopyWithImpl(this._value, this._then);

  final ImageCropperState _value;
  // ignore: unused_field
  final $Res Function(ImageCropperState) _then;
}

/// @nodoc
abstract class _$InitialCopyWith<$Res> {
  factory _$InitialCopyWith(_Initial value, $Res Function(_Initial) then) =
      __$InitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$InitialCopyWithImpl<$Res> extends _$ImageCropperStateCopyWithImpl<$Res>
    implements _$InitialCopyWith<$Res> {
  __$InitialCopyWithImpl(_Initial _value, $Res Function(_Initial) _then)
      : super(_value, (v) => _then(v as _Initial));

  @override
  _Initial get _value => super._value as _Initial;
}

/// @nodoc

class _$_Initial implements _Initial {
  const _$_Initial();

  @override
  String toString() {
    return 'ImageCropperState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(Uint8List imageData) newImageLoaded,
    required TResult Function() cropperOpened,
    required TResult Function(Uint8List imageData) newImageCropped,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(Uint8List imageData)? newImageLoaded,
    TResult Function()? cropperOpened,
    TResult Function(Uint8List imageData)? newImageCropped,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(Uint8List imageData)? newImageLoaded,
    TResult Function()? cropperOpened,
    TResult Function(Uint8List imageData)? newImageCropped,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_NewImageLoaded value) newImageLoaded,
    required TResult Function(_CropperOpened value) cropperOpened,
    required TResult Function(_NewImageCropped value) newImageCropped,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_NewImageLoaded value)? newImageLoaded,
    TResult Function(_CropperOpened value)? cropperOpened,
    TResult Function(_NewImageCropped value)? newImageCropped,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_NewImageLoaded value)? newImageLoaded,
    TResult Function(_CropperOpened value)? cropperOpened,
    TResult Function(_NewImageCropped value)? newImageCropped,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements ImageCropperState {
  const factory _Initial() = _$_Initial;
}

/// @nodoc
abstract class _$NewImageLoadedCopyWith<$Res> {
  factory _$NewImageLoadedCopyWith(
          _NewImageLoaded value, $Res Function(_NewImageLoaded) then) =
      __$NewImageLoadedCopyWithImpl<$Res>;
  $Res call({Uint8List imageData});
}

/// @nodoc
class __$NewImageLoadedCopyWithImpl<$Res>
    extends _$ImageCropperStateCopyWithImpl<$Res>
    implements _$NewImageLoadedCopyWith<$Res> {
  __$NewImageLoadedCopyWithImpl(
      _NewImageLoaded _value, $Res Function(_NewImageLoaded) _then)
      : super(_value, (v) => _then(v as _NewImageLoaded));

  @override
  _NewImageLoaded get _value => super._value as _NewImageLoaded;

  @override
  $Res call({
    Object? imageData = freezed,
  }) {
    return _then(_NewImageLoaded(
      imageData == freezed
          ? _value.imageData
          : imageData // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class _$_NewImageLoaded implements _NewImageLoaded {
  const _$_NewImageLoaded(this.imageData);

  @override
  final Uint8List imageData;

  @override
  String toString() {
    return 'ImageCropperState.newImageLoaded(imageData: $imageData)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _NewImageLoaded &&
            const DeepCollectionEquality().equals(other.imageData, imageData));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(imageData));

  @JsonKey(ignore: true)
  @override
  _$NewImageLoadedCopyWith<_NewImageLoaded> get copyWith =>
      __$NewImageLoadedCopyWithImpl<_NewImageLoaded>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(Uint8List imageData) newImageLoaded,
    required TResult Function() cropperOpened,
    required TResult Function(Uint8List imageData) newImageCropped,
  }) {
    return newImageLoaded(imageData);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(Uint8List imageData)? newImageLoaded,
    TResult Function()? cropperOpened,
    TResult Function(Uint8List imageData)? newImageCropped,
  }) {
    return newImageLoaded?.call(imageData);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(Uint8List imageData)? newImageLoaded,
    TResult Function()? cropperOpened,
    TResult Function(Uint8List imageData)? newImageCropped,
    required TResult orElse(),
  }) {
    if (newImageLoaded != null) {
      return newImageLoaded(imageData);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_NewImageLoaded value) newImageLoaded,
    required TResult Function(_CropperOpened value) cropperOpened,
    required TResult Function(_NewImageCropped value) newImageCropped,
  }) {
    return newImageLoaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_NewImageLoaded value)? newImageLoaded,
    TResult Function(_CropperOpened value)? cropperOpened,
    TResult Function(_NewImageCropped value)? newImageCropped,
  }) {
    return newImageLoaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_NewImageLoaded value)? newImageLoaded,
    TResult Function(_CropperOpened value)? cropperOpened,
    TResult Function(_NewImageCropped value)? newImageCropped,
    required TResult orElse(),
  }) {
    if (newImageLoaded != null) {
      return newImageLoaded(this);
    }
    return orElse();
  }
}

abstract class _NewImageLoaded implements ImageCropperState {
  const factory _NewImageLoaded(Uint8List imageData) = _$_NewImageLoaded;

  Uint8List get imageData;
  @JsonKey(ignore: true)
  _$NewImageLoadedCopyWith<_NewImageLoaded> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$CropperOpenedCopyWith<$Res> {
  factory _$CropperOpenedCopyWith(
          _CropperOpened value, $Res Function(_CropperOpened) then) =
      __$CropperOpenedCopyWithImpl<$Res>;
}

/// @nodoc
class __$CropperOpenedCopyWithImpl<$Res>
    extends _$ImageCropperStateCopyWithImpl<$Res>
    implements _$CropperOpenedCopyWith<$Res> {
  __$CropperOpenedCopyWithImpl(
      _CropperOpened _value, $Res Function(_CropperOpened) _then)
      : super(_value, (v) => _then(v as _CropperOpened));

  @override
  _CropperOpened get _value => super._value as _CropperOpened;
}

/// @nodoc

class _$_CropperOpened implements _CropperOpened {
  const _$_CropperOpened();

  @override
  String toString() {
    return 'ImageCropperState.cropperOpened()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _CropperOpened);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(Uint8List imageData) newImageLoaded,
    required TResult Function() cropperOpened,
    required TResult Function(Uint8List imageData) newImageCropped,
  }) {
    return cropperOpened();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(Uint8List imageData)? newImageLoaded,
    TResult Function()? cropperOpened,
    TResult Function(Uint8List imageData)? newImageCropped,
  }) {
    return cropperOpened?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(Uint8List imageData)? newImageLoaded,
    TResult Function()? cropperOpened,
    TResult Function(Uint8List imageData)? newImageCropped,
    required TResult orElse(),
  }) {
    if (cropperOpened != null) {
      return cropperOpened();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_NewImageLoaded value) newImageLoaded,
    required TResult Function(_CropperOpened value) cropperOpened,
    required TResult Function(_NewImageCropped value) newImageCropped,
  }) {
    return cropperOpened(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_NewImageLoaded value)? newImageLoaded,
    TResult Function(_CropperOpened value)? cropperOpened,
    TResult Function(_NewImageCropped value)? newImageCropped,
  }) {
    return cropperOpened?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_NewImageLoaded value)? newImageLoaded,
    TResult Function(_CropperOpened value)? cropperOpened,
    TResult Function(_NewImageCropped value)? newImageCropped,
    required TResult orElse(),
  }) {
    if (cropperOpened != null) {
      return cropperOpened(this);
    }
    return orElse();
  }
}

abstract class _CropperOpened implements ImageCropperState {
  const factory _CropperOpened() = _$_CropperOpened;
}

/// @nodoc
abstract class _$NewImageCroppedCopyWith<$Res> {
  factory _$NewImageCroppedCopyWith(
          _NewImageCropped value, $Res Function(_NewImageCropped) then) =
      __$NewImageCroppedCopyWithImpl<$Res>;
  $Res call({Uint8List imageData});
}

/// @nodoc
class __$NewImageCroppedCopyWithImpl<$Res>
    extends _$ImageCropperStateCopyWithImpl<$Res>
    implements _$NewImageCroppedCopyWith<$Res> {
  __$NewImageCroppedCopyWithImpl(
      _NewImageCropped _value, $Res Function(_NewImageCropped) _then)
      : super(_value, (v) => _then(v as _NewImageCropped));

  @override
  _NewImageCropped get _value => super._value as _NewImageCropped;

  @override
  $Res call({
    Object? imageData = freezed,
  }) {
    return _then(_NewImageCropped(
      imageData == freezed
          ? _value.imageData
          : imageData // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class _$_NewImageCropped implements _NewImageCropped {
  const _$_NewImageCropped(this.imageData);

  @override
  final Uint8List imageData;

  @override
  String toString() {
    return 'ImageCropperState.newImageCropped(imageData: $imageData)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _NewImageCropped &&
            const DeepCollectionEquality().equals(other.imageData, imageData));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(imageData));

  @JsonKey(ignore: true)
  @override
  _$NewImageCroppedCopyWith<_NewImageCropped> get copyWith =>
      __$NewImageCroppedCopyWithImpl<_NewImageCropped>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(Uint8List imageData) newImageLoaded,
    required TResult Function() cropperOpened,
    required TResult Function(Uint8List imageData) newImageCropped,
  }) {
    return newImageCropped(imageData);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(Uint8List imageData)? newImageLoaded,
    TResult Function()? cropperOpened,
    TResult Function(Uint8List imageData)? newImageCropped,
  }) {
    return newImageCropped?.call(imageData);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(Uint8List imageData)? newImageLoaded,
    TResult Function()? cropperOpened,
    TResult Function(Uint8List imageData)? newImageCropped,
    required TResult orElse(),
  }) {
    if (newImageCropped != null) {
      return newImageCropped(imageData);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_NewImageLoaded value) newImageLoaded,
    required TResult Function(_CropperOpened value) cropperOpened,
    required TResult Function(_NewImageCropped value) newImageCropped,
  }) {
    return newImageCropped(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_NewImageLoaded value)? newImageLoaded,
    TResult Function(_CropperOpened value)? cropperOpened,
    TResult Function(_NewImageCropped value)? newImageCropped,
  }) {
    return newImageCropped?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_NewImageLoaded value)? newImageLoaded,
    TResult Function(_CropperOpened value)? cropperOpened,
    TResult Function(_NewImageCropped value)? newImageCropped,
    required TResult orElse(),
  }) {
    if (newImageCropped != null) {
      return newImageCropped(this);
    }
    return orElse();
  }
}

abstract class _NewImageCropped implements ImageCropperState {
  const factory _NewImageCropped(Uint8List imageData) = _$_NewImageCropped;

  Uint8List get imageData;
  @JsonKey(ignore: true)
  _$NewImageCroppedCopyWith<_NewImageCropped> get copyWith =>
      throw _privateConstructorUsedError;
}
